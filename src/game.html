<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Hello React</title>
    <script src="https://fb.me/react-0.14.7.js"></script>
    <script src="https://fb.me/react-dom-0.14.7.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js"></script>
    <style>
      #canvas {
        position: absolute;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
      .permanent {
        display: inline-block;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" width="300" height="300"></canvas>
    <script>
      function clone(obj) {
        return JSON.parse(JSON.stringify(obj)); // TODO: something better
      }

      var game = {
        player_ids: [3, 7],
        moves: [],
        state: {},
      };
      var game_info = undefined;
      var chat = undefined;
      var socket = undefined;
      var view = undefined;
      window.onload = function() {
        var readCookie = function(name) {
          var c = document.cookie.split('; ');
          for (var i = c.length - 1; i >= 0; i--) {
            var cc = c[i].split('=');
            if (cc[0] === name) {
              return cc[1];
            }
          }
          throw 'Cookie '+name+' not found.';
        };

        socket = new WebSocket('ws://192.168.1.203:8080');
        socket.onerror = function(error) {
          console.log("WebSocket error: " + error);
        };
        socket.onopen = function(e) {
          console.log("WebSocket open");
          socket.send(JSON.stringify({
            type: 'hello',
            session_id: readCookie('session_id'),
            game_id: window.location.href.split('/').pop(),
          }));
        };
        socket.onmessage = function(e) {
          var msg = JSON.parse(e.data);
          if (msg.type === 'chat') {
            chat.add(msg.chat);
          }
          else if (msg.type === 'chats') {
            for (var i = msg.chats.length - 1; i >= 0; i--) {
              chat.add(msg.chats[i]);
            }
          }
          else if (msg.type === 'greetings') {
            game_info = msg;
            view.forceUpdate();
          }
          else if (msg.type === 'state') {
            view.set_state(msg.state);
          }
          else {
            console.log('Unrecognized WebSocket message type: %s', msg.type);
          }
        };
        socket.onclose = function(e) {
          console.log("WebSocket closed");
        };
      };
    </script>
    <div id="chat"></div>
    <script type="text/babel">
      var Chat = React.createClass({
        getInitialState: function() {
          return {chats: []};
        },
        add: function(msg) {
          this.setState({chats: [msg, ...this.state.chats]});
        },
        send: function(e) {
          e.preventDefault();
          socket.send(JSON.stringify({
            type: 'chat',
            text: this.refs.message.value,
          }));
          this.refs.message.value = '';
        },
        render: function() {
          var chats = [];
          for (var i = this.state.chats.length - 1; i >= 0; i--) {
            var chat = this.state.chats[i];
            chats.push(
              <div key={i}>
                [{chat.timestamp}]
                <strong>{chat.username}</strong>:
                {chat.text}
              </div>
            );
          }
          return (
            <form onSubmit={this.send}>
              {chats}
              <input type="text" placeholder="enter a message" ref="message" />
              <input type="submit" value="send" />
            </form>
          );
        },
      });
      chat = ReactDOM.render(<Chat />, document.getElementById('chat'));
    </script>
    <div id="view"></div>
    <script type="text/babel">
      var View = React.createClass({
        getInitialState: function() {
          return {
            game: null,
            attacker: null,
          };
        },
        get_permanent: function(copy_id) {
          for (let player_id of Object.keys(this.state.game.players)) {
            for (let perm of this.state.game.players[player_id].permanents) {
              if (perm.copy_id == copy_id) {
                return perm;
              }
            }
          }
          throw 'Permanent ' + copy_id + ' not found';
        },
        render_canvas: function() {
          console.log('render');
          var canvas = document.getElementById('canvas');
          var ctx = canvas.getContext('2d');
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;

          if (this.state.game === null) {
            return;
          }

          ctx.strokeStyle = 'rgb(200, 0, 0)';

          for (let attack of this.state.game.attacks) {
            let attacker = this.get_permanent(attack.attacker);
            let target = this.get_permanent(attack.target);
            let attacker_el = document.getElementById('perm_'+attack.attacker);
            let target_el = document.getElementById('perm_'+attack.target);
            console.log(attacker_el);
            console.log(target_el);

            ctx.beginPath();
            ctx.moveTo(attacker_el.offsetLeft, attacker_el.offsetTop);
            ctx.lineTo(target_el.offsetLeft, target_el.offsetTop);
            ctx.stroke();
          }
        },
        componentDidUpdate: function() {
          setTimeout(this.render_canvas());
        },
        set_state: function(game_state) {
          this.setState({
            game: game_state,
            attacker: this.state.attacker,
          });
        },
        yield: function(e) {
          socket.send(JSON.stringify({type: 'yield'}));
        },
        draw: function(e) {
          socket.send(JSON.stringify({type: 'draw'}));
        },
        play: function(card, e) {
          socket.send(JSON.stringify({type: 'play',copy_id: card.copy_id}));
        },
        attack_start: function(card, e) {
          this.setState({
            game: clone(this.state.game),
            attacker: card,
          });
        },
        attack_finish: function(target, e) {
          socket.send(JSON.stringify({
            type: 'attack',
            attacker: this.state.attacker.copy_id,
            target: target.copy_id,
          }));
          this.setState({
            game: clone(this.state.game),
            attacker: null,
          });
        },
        defend: function(e) {
          socket.send(JSON.stringify({type: 'defend'}));
        },
        render: function() {
          console.log(this.state);

          var game = this.state.game;

          if (typeof game_info === 'undefined' || game === null) {
            return (<i>Connecting..</i>);
          }

          var that = this;

          var me = game.players[game_info.user_id];

          var enemy = null;
          for (let key in game.players) {
            if (game.players.hasOwnProperty(key) &&
                key != game_info.user_id) {
              enemy = game.players[key];
              break;
            }
          }
          if (enemy === null) {
            throw 'enemy not found';
          }

          var hand = [];
          for (let i = 0; i < me.hand.length; i++) {
            hand.push(
              <strong key={i}>
                {me.hand[i].name+" "}
                <input type="button" onClick={that.play.bind(this, me.hand[i])}
                  value="play" />
              </strong>
            );
          }

          var my_turn = game.turn_player_id == game_info.user_id;
          var draw_possible = my_turn ? game.draw_possible : 0;

          let render_permanents = function(perms, are_mine) {
            let ret = [];

            let can_attack = my_turn && that.state.attacker === null;
            let is_attacking = my_turn && that.state.attacker !== null;

            for (let i = 0; i < perms.length; i++) {
              var attack_with = '';
              if (are_mine && typeof perms[i].attack !== 'undefined') {
                attack_with = (
                  <input type="button" value="attack with"
                    disabled={!can_attack || perms[i].tapped ||
                              game.phase !== 'main'}
                    onClick={that.attack_start.bind(null, perms[i])} />
                );
              }

              var attack = '';
              if (is_attacking && !are_mine &&
                  typeof perms[i].defense !== 'undefined') {
                attack = (
                  <input type="button" value="attack"
                    onClick={that.attack_finish.bind(null, perms[i])} />
                );
              }

              ret.push(
                <div key={i} id={'perm_' + perms[i].copy_id}
                     className="permanent">
                  <strong>{perms[i].name+" "}</strong>
                  {attack_with}
                  {attack}
                </div>
              );
            }
            return ret;
          };

          let permanents = render_permanents(me.permanents, true);
          let enemy_permanents = render_permanents(enemy.permanents);

          return (
            <div>
              <div>
                It is <strong>{my_turn ? '' : 'not '}your turn</strong>.
                Phase: <strong>{game.phase}</strong>
                <input type="button" onClick={this.defend} value="defend"
                  disabled={!my_turn || game.phase !== 'defend'} />
                <input type="button" onClick={this.yield} value="yield"
                  disabled={!my_turn} />
              </div>
              <div>Scrap: {me.scrap}</div>
              <div>
                You can draw {draw_possible} cards.
                <input type="button" onClick={this.draw} value="draw"
                  disabled={!draw_possible} />
              </div>
              <div>Your permanents: {permanents}</div>
              <div>Your hand: {hand}</div>
              <hr />
              <div>Enemy scrap: {enemy.scrap}</div>
              <div>Enemy permanents: {enemy_permanents}</div>
            </div>
          );
        },
      });
      view = ReactDOM.render(<View />, document.getElementById('view'));
    </script>
  </body>
</html>
